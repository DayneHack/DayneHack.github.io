<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dayne Hack</title>
    <link rel="stylesheet" href="css/style.css"
</head>
<style>
    h1 {
        font-size: 60px;
    }
    h2 {
        font-size: 45px;
    }
    h3 {
        font-size: 30px;
    }
    h4 {
        font-size: 40px;
    }
</style>
<div class="header">
    <h1>Dayne Hack</h1>
    <p>(604) 358-6003</p>
    <a href="mailto: daynehack@gmail.com">Email</a>
    <a href="https://drive.google.com/file/d/1ajz7yAFVERPiyKvOJJyC4v55_N3D8WiX/view?usp=sharing">Resume</a>
    <a href="https://www.github.com/DayneHack/">Github</a>
    <a href="https://www.linkedin.com/in/daynehack/">Linkedin</a>
    
</div>

<hr class="one">
<hr class="one">

<body>

<h4>Data Analytics/Science Projects</h4>

<h3>CSGO Item Analysis</h3>
<a href="https://github.com/DayneHack/CSGO-Item-Analysis">Repo</a>
<a href="https://public.tableau.com/views/CSGO-Item-Analysis/Main?:language=en-US&:display_count=n&:origin=viz_share_link">Dashboard</a>

<div class="row">
    <div class="columnOne">
        <img src="/pics/14.png" class="imgOne" alt="14">
    </div>
    <div class="columnOne">
        <p>In this project I explore the weapon skins of the primary 3 rifles in CSGO and try to determine if it is possible to accurately predict the price of a skin based off of multiple factors. Looked at all of the skins of the primary 3 rifles and attempted to see if their price correlates to their rarity, condition, and release year. Data was pulled from the Steam Market API and cleaned to isolate the variables I wanted to explore. An exploratory data analysis was performed looking to find a correlation between a skin's average price and its rarity, condition, and release year. Then, I built and optimized models using Linear Regression and Random Forest to attempt to predict a skins price. Above is a Tableau visalization for this project. More visualizations done in seaborn can be found on the github repo for this project.</p>
    </div>
</div>








<hr class="two">

<h3>Titanic Passenger Analysis</h3>
<a href="https://github.com/DayneHack/Titanic-Passenger-Dashboard">Repo</a>
<a href="https://1drv.ms/x/s!Aqn3UIGzZY_2rRbzXuLiP3ZkAaOA?e=XXHFIm">Dashboard</a>

<div class="row">
    <div class="columnTwo">
        <img src="/pics/15.png" class="imgTwo" alt="15">
    </div>
    <div class="columnTwo">
        <p>In this project I explore a dataset of every passenger that was on the Titanic to see which characteristics were correlated to survival of the tragedy. I cleaned the data by removing columns that were not useful such as ticket number, and by removing data entries that had missing data. Next I created pivot tables to determine which variables were more likely to be correlated to survival such as class, age, and port of origin. An interactive dashboard made in Excel can be found above.</p>
    </div>
</div>

<hr class="two">

<h3>Classifier comparison</h3>
<a href="https://github.com/DayneHack/data-science-projects/blob/main/classifier-comparison.ipynb">Repo</a>
<p>Random forest vs decision trees classifier comparison. The two classifers are compared on the same dataset after it has been cleaned and balanced. The dataset was balanced by dropping unnecessary columns, filling in missing values, and mapping categorical features to numerical values. To balance the data I used SMOTE and overbalanced because there was a category with far too few cases and I didn't want to remove the majority of samples. We see evidence of overfittting for both random forest and decision trees as the classifier seems to be more accurate on the training data than the testing data. Random forest seemed to have performed better on predicting the validation set as well as a separate test set by a few percent. </p>
    
<hr class="two">
    
<h3>K-means clustering</h3>
<a href="https://github.com/DayneHack/data-science-projects/tree/main/kmeans%20clustering">Repo</a>
<p>My implementation of kmeans clustering from scratch with a slight improvement. The initial centroid selection is improved upon by randomly selecting the first centroid, and then subsequently picking further centroids based off of distance to previously selected centroids. For example, if a centroid is picked, the next centroid will be randomly selected with a probability based off how far it is from the centroids that have been selected.</p>
    
<img src="/pics/5.png" alt="5">
<img src="/pics/6.png" alt="6">
<img src="/pics/7.png" alt="7">

<hr class="one">
<hr class="one">

<h2>Programming Projects</h2>

<h3>Chess Position Gallery</h3>
<a href="https://github.com/DayneHack/chess-position-gallery">Repo</a>
<p>Full-stack MERN (MongoDB, Express.js, React.js, Node.js) application for creating chess positions by dragging pieces onto a board and saving them in the gallery for later viewing. At the moment the images saved in the gallery are misaligned and not in their final state but will continue to be worked on. Despite this, the four CRUD functions are working properly.</p>

<img src="/pics/11.png" alt="11" className="chess_images">
<img src="/pics/12.png" alt="12" className="chess_images">
<img src="/pics/13.png" alt="13" className="chess_images">

<hr class="two">

<h3>Rain Notifier</h3>
<a href="https://github.com/DayneHack/rain-notifier">Repo</a>
<br>
<br>
<a href="https://rain-notifier.herokuapp.com/">Website</a>
<p>Web app that allows a user to input any city or region in the world, and they will be told if it will rain in the next 12 hours in that region. Uses AccuWeather api to determine both the location inputted and the weather in the next 12 hours at that location.</p>

<hr class="two">

<h3>Bandwidth Monitor</h3>
<a href="https://github.com/DayneHack/bandwidth-monitor">Repo</a>
<p>Bandwidth monitor that tracks and records the amount of information you upload and download daily. Every night at midnight a spreadsheet is updated so that you can compare your bandwidth usage from day to day.</p>

<hr class="two">

<h3>Chess Engine</h3>
<a href="https://github.com/DayneHack/chess-engine">Repo</a>
<p>Since the base minimax algorithm sets no limitations for how many branches of the search tree it expands, it is quite a slow algorithm. Minimax with alpha-beta pruning is significantly faster than minimax with equal accuracy. Minimax with alpha beta pruning and null move heuristic is about the same average turn time with marginally better accuracy.</p>

<hr class="two">

<h3>Produce Picker</h3>

<a href="https://github.com/DayneHack/FruitFinder">Repo</a>
<p>Android Studio Java game where you match images with each other on different pre-generated "cards". Has functionality to pull images from the internet or from your phone's storage.</p>

<img src="/pics/1.png" alt="1">
<img src="/pics/2.png" alt="2">
<img src="/pics/3.png" alt="3">
<img src="/pics/4.png" alt="4">



<hr class="one">
<hr class="one">





</body>
</html>